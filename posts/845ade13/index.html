<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>调研实现高性能动画 | ——╅ 萧 ☯ ℡'s Blog</title><meta name="description" content="快速响应和高度交互的页面往往能够吸引大量的用户羣体. 相反, 如果页面存在性能低下的动画, 动画不流畅, 动画过程中页面闪烁等等,如此粗糙的交互体验必然丧失用户量."><meta name="keywords" content="JS,性能优化"><meta name="author" content="萧"><meta name="copyright" content="萧"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/image/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="manifest" href="/image/pwa/manifest.json"><meta name="theme-color" content="#fff"><meta name="msapplication-TileColor" content="#fff"><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"><meta name="google-site-verification" content="8d5fb649bdfda9cb"><meta name="baidu-site-verification" content="a2ac21ed3bfd04546458acf79469e44c"><meta name="360-site-verification" content="8c0e5fdcdef668cffe962f1cf3f99a03"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="调研实现高性能动画"><meta name="twitter:description" content="快速响应和高度交互的页面往往能够吸引大量的用户羣体. 相反, 如果页面存在性能低下的动画, 动画不流畅, 动画过程中页面闪烁等等,如此粗糙的交互体验必然丧失用户量."><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/animation_optimize_cover.jpg"><meta property="og:type" content="article"><meta property="og:title" content="调研实现高性能动画"><meta property="og:url" content="http://notes.seirhsiao.com/posts/845ade13/"><meta property="og:site_name" content="——╅ 萧 ☯ ℡'s Blog"><meta property="og:description" content="快速响应和高度交互的页面往往能够吸引大量的用户羣体. 相反, 如果页面存在性能低下的动画, 动画不流畅, 动画过程中页面闪烁等等,如此粗糙的交互体验必然丧失用户量."><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/animation_optimize_cover.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '2'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="http://notes.seirhsiao.com/posts/845ade13/"><link rel="prev" title="添加Windows Terminal到鼠标右键菜单" href="/http:/notes.seirhsiao.com/posts/c621cf12/"><link rel="next" title="在浏览器输入 URL 回车之后发生了什么（超详细版）" href="/http:/notes.seirhsiao.com/posts/20bbe8ff/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-70461570-1', 'auto');
ga('send', 'pageview');

</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-8919908724705274",
enable_page_level_ads: true
});


</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"502RMOS83O","apiKey":"c0621f18b83bdbdec63c1ac56235a5ea","indexName":"Jerryc","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://notes.seirhsiao.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: 萧","link":"链接: http://notes.seirhsiao.com/posts/845ade13/","source":"来源: ——╅ 萧 ☯ ℡'s Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><link rel="alternate" href="/atom.xml" title="——╅ 萧 ☯ ℡'s Blog" type="application/atom+xml">
</head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">——╅ 萧 ☯ ℡'s Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">122</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">106</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">33</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于setTimeout或者setInterval实现的动画"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">基于setTimeout或者setInterval实现的动画</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#基于帧算法实现的动画"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">基于帧算法实现的动画</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#基于时间算法实现的动画"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">基于时间算法实现的动画</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#基于setTimeout或者setInterval实现动画存在的问题"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">基于setTimeout或者setInterval实现动画存在的问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于requestAnimationFrame实现的动画"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">基于requestAnimationFrame实现的动画</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#浏览器渲染过程"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">浏览器渲染过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#HTML-Parser"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">HTML Parser</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Calculate-Style"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">Calculate Style</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Layout"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">Layout</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Rasterizer"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">Rasterizer</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Paint"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">Paint</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Composite-Layers"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">Composite Layers</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#影响动画渲染性能的因素"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">影响动画渲染性能的因素</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#重排"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">重排</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#重绘"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">重绘</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#动画渲染性能优化"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">动画渲染性能优化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#在Composite这步优化动画"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">在Composite这步优化动画</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#在-GPU-上运行动画"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">在 GPU 上运行动画</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#参考资料"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">参考资料</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于setTimeout或者setInterval实现的动画"><span class="toc-number">1.</span> <span class="toc-text">基于setTimeout或者setInterval实现的动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基于帧算法实现的动画"><span class="toc-number">1.1.</span> <span class="toc-text">基于帧算法实现的动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于时间算法实现的动画"><span class="toc-number">1.2.</span> <span class="toc-text">基于时间算法实现的动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于setTimeout或者setInterval实现动画存在的问题"><span class="toc-number">1.3.</span> <span class="toc-text">基于setTimeout或者setInterval实现动画存在的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于requestAnimationFrame实现的动画"><span class="toc-number">2.</span> <span class="toc-text">基于requestAnimationFrame实现的动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器渲染过程"><span class="toc-number">3.</span> <span class="toc-text">浏览器渲染过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML-Parser"><span class="toc-number">3.1.</span> <span class="toc-text">HTML Parser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calculate-Style"><span class="toc-number">3.2.</span> <span class="toc-text">Calculate Style</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Layout"><span class="toc-number">3.3.</span> <span class="toc-text">Layout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rasterizer"><span class="toc-number">3.4.</span> <span class="toc-text">Rasterizer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Paint"><span class="toc-number">3.5.</span> <span class="toc-text">Paint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Composite-Layers"><span class="toc-number">3.6.</span> <span class="toc-text">Composite Layers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#影响动画渲染性能的因素"><span class="toc-number">4.</span> <span class="toc-text">影响动画渲染性能的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重排"><span class="toc-number">4.1.</span> <span class="toc-text">重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重绘"><span class="toc-number">4.2.</span> <span class="toc-text">重绘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动画渲染性能优化"><span class="toc-number">5.</span> <span class="toc-text">动画渲染性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在Composite这步优化动画"><span class="toc-number">5.1.</span> <span class="toc-text">在Composite这步优化动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在-GPU-上运行动画"><span class="toc-number">5.2.</span> <span class="toc-text">在 GPU 上运行动画</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/static/cover/11867.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">调研实现高性能动画</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-24<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-07</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/">Web</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">4.2k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 13 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><div class="note info">
            <p>本文转载自<a href="https://relign.github.io/Animation/animation-optimize/" target="_blank" rel="external nofollow noreferrer noopener">【总结】调研实现高性能动画</a></p>
          </div>

<blockquote>
<p>本文是调研如何实现高性能动画, 提升用户体验的总结, 文章内容来源于对看过的相关技术文章的总结, 相关技术文章已列到文章末尾, 如有遗漏, 敬请谅解.</p>
</blockquote>
<p>快速响应和高度交互的页面往往能够吸引大量的用户羣体. 相反, 如果页面存在性能低下的动画, 动画不流畅, 动画过程中页面闪烁等等, 如此粗糙的交互体验必然丧失用户量.</p>
<p>对于大多数的设备而言, 屏幕以 60 次每秒的频率刷新, 即<code>60HZ</code>. 如果一个动画中的某些帧超过了这个时间, 就会导致浏览器的刷新频率跟不上设备的刷新频率（跳帧现象）, 出现页面闪烁. 因此, 高性能的动画都应该保持在<code>60fps</code>左右.</p>
<p>接下来我们看几种动画的实现方式.</p>
<h3 id="基于setTimeout或者setInterval实现的动画"><a href="#基于setTimeout或者setInterval实现的动画" class="headerlink" title="基于setTimeout或者setInterval实现的动画"></a>基于<code>setTimeout</code>或者<code>setInterval</code>实现的动画</h3><h4 id="基于帧算法实现的动画"><a href="#基于帧算法实现的动画" class="headerlink" title="基于帧算法实现的动画"></a>基于帧算法实现的动画</h4><iframe height="471" scrolling="no" title="rWeGoX" src="//codepen.io/relign/embed/rWeGoX/?height=471&amp;theme-id=0&amp;default-tab=result&amp;embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">

<p>这是一个基于帧算法实现的 JavaScript 动画, 这里设置的每秒钟更新 60 次, 即<code>60fps</code>. 大家可以看到现在的动画还是非常流畅的. 动画的帧率也在 60 附近.</p>
<p>但是由于 JavaScript 运行时需要耗费时间, 而 JavaScript 又是单线程的, 所以如果一个定时器如果比较耗时的话, 是会阻塞下一个定时器的执行. 所以即使你这里设置了<code>1000 / 60</code>每秒<code>60帧</code>的帧率, 在不同的浏览器平台的差异也会导致实际上你的没有<code>60fps</code>的帧率.</p>
<p>所以上面代码在一个手机上执行的时候可能有<code>60fps</code>的帧率, 在另外一个手机上可能就只有<code>30fps</code>, 更甚可能只有<code>10fps</code>.</p>
<p>我们去模拟一下这几个帧率下的动画:</p>
<iframe height="710" scrolling="no" title="xRVXyG" src="//codepen.io/relign/embed/xRVXyG/?height=710&amp;theme-id=0&amp;default-tab=result&amp;embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;"></iframe>

<p>很明显产生的交互效果是不符合预期的. 导致这种情况的原因很简单, 因为我们计算和绘制每个<code>div</code>位置的时候是在每帧更新, 每帧移动<code>2px</code>. 在<code>60fps</code>的情况下, 我们 1 秒钟会执行<code>60帧</code>, 所以小块每秒钟会移动<code>60 * 2 = 120px</code>; 如果是<code>30fps</code>, 小块每秒就移动<code>30 * 2 = 60px</code>, 以此类推<code>10fps</code>就是每秒移动<code>20px</code>. 三个小块在单位时间内移动的距离不一样.</p>
<h4 id="基于时间算法实现的动画"><a href="#基于时间算法实现的动画" class="headerlink" title="基于时间算法实现的动画"></a>基于时间算法实现的动画</h4><p>针对于这种情况, 我们对其作出改进. 我们不再以帧为基准来更新方块的位置, 而是以时间为单位更新. 也就是说, 我们之前是<code>px/frame</code>, 现在换成<code>px/ms</code>.</p>
<iframe height="602" scrolling="no" title="XNdVEE" src="//codepen.io/relign/embed/XNdVEE/?height=602&amp;theme-id=0&amp;default-tab=result&amp;embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;"></iframe>

<p>在这里, 我们先确定一个固定更新的时间片, 如固定为<code>60fps</code>时一帧的时间:<code>1000 / 60 = 0.167ms</code>. 然后积累过去的时间, 然后根据固定时间片分片进行更新. 也就说, 即使这一帧和上一帧相差过去了<code>100ms</code>, 我也会把这 100ms 分成很多个<code>0.167ms</code>来执行<code>update</code>函数. 这样做有两个好处:</p>
<ul>
<li>固定的时间片足够小，更新的时候可以减少动画失帧</li>
<li>不同帧率, 不管你是<code>60</code>,<code>30</code>, 还是<code>10fps</code>, 也是根据固定时间片来执行 update 函数, 所以即使有损失, 不同帧率之间的损失是一样的. 那么我们三个方块就可以达到同步移动的效果的了!</li>
</ul>
<h4 id="基于setTimeout或者setInterval实现动画存在的问题"><a href="#基于setTimeout或者setInterval实现动画存在的问题" class="headerlink" title="基于setTimeout或者setInterval实现动画存在的问题"></a>基于<code>setTimeout</code>或者<code>setInterval</code>实现动画存在的问题</h4><p>使用<code>setTimeout</code>和<code>setInterval</code>来绘制动画, 计算延时的精确度是不够的.</p>
<p>延时的计算依靠的是浏览器的内置时钟, 而时钟的精确度又取决于时钟更新的频率. 不同版本的浏览器, 这个频率是不一样的: IE8 及其之前的 IE 版本更新间隔为 15.6 毫秒, 最新版的 Chrome 与 IE9 + 浏览器的更新频率都为 4ms. 而且如果你使用的是笔记本电脑, 并且在使用电池而非电源的模式下, 为了节省资源, 浏览器会将更新频率切换至于系统时间相同, 更新频率更低.</p>
<p>而另外一个问题, 使用<code>setTimeout</code>和<code>setInterval</code>, 需要面临异步队列问题. 因为异步关系,<code>setTimeout</code>和<code>setInterval</code>中回调函数并非立即执行. 而是需要加入等待队列中. 但问题是, 如果在等待延迟触发的过程中, 有新的同步脚本需要执行, 那么同步脚本不会排在回调之后, 而是立即执行.</p>
<p>例如:</p>
<iframe height="391" scrolling="no" title="jVqYXw" src="//codepen.io/relign/embed/jVqYXw/?height=391&amp;theme-id=0&amp;default-tab=result&amp;embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;"></iframe>

<p>很显然, 这样的动画交互体验是不可控的.</p>
<h3 id="基于requestAnimationFrame实现的动画"><a href="#基于requestAnimationFrame实现的动画" class="headerlink" title="基于requestAnimationFrame实现的动画"></a>基于<code>requestAnimationFrame</code>实现的动画</h3><p>针对<code>setTimeout</code>和<code>setInterval</code>实现动画存在的缺陷,<code>Mozilla</code>首先推出了<code>mozRequestAnimationFrame</code>, 通过它告诉浏览器某些 JavaScript 代码将要执行动画, 这样浏览器可以在运行某些代码后进行适当的优化. 之后,<code>Chrome</code>和<code>IE10+</code>也都给出了自己的实现,<code>webkitRequestAnimationFrame</code>和<code>msRequestAnimationFrame</code>. 后来随着<code>HTML5</code>新的 API 发布,<code>requestAnimationFrame</code>被正式推出.</p>
<p>官方定义:</p>
<blockquote>
<p>window.requestAnimationFrame() 这个方法是用来在页面重绘之前, 通知浏览器调用一个指定的函数, 以满足开发者操作动画的需求. 这个方法接受一个函数为参, 该函数会在重绘前调用.</p>
</blockquote>
<p>注意: 如果想得到连贯的逐帧动画, 函数中必须重新调用 <code>requestAnimationFrame()</code>.</p>
<iframe height="371" scrolling="no" title="qqZxqW" src="//codepen.io/relign/embed/qqZxqW/?height=371&amp;theme-id=0&amp;default-tab=result&amp;embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;"></iframe>

<p><code>requestAnimationFrame</code>最大的好处在于可以可以避免浏览器不必要的重绘. 想要理解这个好处, 我们首先需要简单了解一下浏览器的渲染过程.</p>
<h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p>要实现一个高性能的动画, 首选我们必须对浏览器的渲染机制有所了解:</p>
<blockquote>
<p>更加详细的渲染过程解读详见<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="external nofollow noreferrer noopener">浏览器的工作原理：新式网络浏览器幕后揭祕</a></p>
</blockquote>
<p>Chrome 渲染过程:<br><img alt="webkitflow.png" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/webkitflow.png" class="lazyload"></p>
<p>从图中可以看出, 浏览在渲染页面过程中依次经历了:</p>
<ol>
<li>HTML Parse(html 解析)</li>
<li>Calculate Style(计算样式)</li>
<li>Layout(布局)</li>
<li>Rasterizer(光栅化)</li>
<li>Paint(绘制)</li>
<li>Composite Layers(渲染层合并)</li>
</ol>
<h4 id="HTML-Parser"><a href="#HTML-Parser" class="headerlink" title="HTML Parser"></a>HTML Parser</h4><p>发送<code>http</code>请求, 获取请求内容, 然后解析 HTML 的过程. 更加详细的可以看这里 <a href="https://github.com/alex/what-happens-when" target="_blank" rel="external nofollow noreferrer noopener">What happens when…</a> 以及对应的翻译文档<a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external nofollow noreferrer noopener">当 ··· 时发生了什么?</a></p>
<h4 id="Calculate-Style"><a href="#Calculate-Style" class="headerlink" title="Calculate Style"></a>Calculate Style</h4><p>即计算样式.</p>
<p>Calculate 被触发的时候做的事情就是处理 JavaScript 给元素设置的样式. 此时 Recalculate Style 会计算 Render 树 (渲染树), 然后从根节点开始进行页面渲染, 将 CSS 附加到 DOM 上的过程.</p>
<p>这个过程是根据 CSS 选择器, 对每个 DOM 元素匹配对应的 CSS 样式. 这一步结束之后, 就确定了每个 DOM 元素上应该应用什么 CSS 样式规则.</p>
<p><strong>任何企图改变元素样式的操作都会触发 Recalculate(重新计算样式)</strong>. 同 Layout 一样, 它们都是 JavaScript 执行完后才触发的.</p>
<h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>计算页面上的布局, 即元素在文档中的位置及大小. 正如前面所述, Layout 计算的是布局位置信息.</p>
<p>上一步确定了每个 DOM 元素的样式规则, 这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置.</p>
<p>需要注意的是: 在页面解析完成后, 任何有可能改变元素位置或大小的样式都会触发这个 Layout 事件.</p>
<p>常见影响布局的 CSS 属性有:</p>
<ul>
<li><code>width</code></li>
<li><code>height</code></li>
<li><code>padding</code></li>
<li><code>margin</code></li>
<li><code>display</code></li>
<li><code>border-width</code></li>
<li><code>border</code></li>
<li><code>top</code></li>
<li><code>position</code></li>
<li><code>font-size</code></li>
<li><code>float</code></li>
<li><code>text-align</code></li>
<li><code>overflow-y</code></li>
<li><code>font-weight</code></li>
<li><code>overflow</code></li>
<li><code>left</code></li>
<li><code>font-family</code></li>
<li><code>line-height</code></li>
<li><code>vertical-align</code></li>
<li><code>right</code></li>
<li><code>clear</code></li>
<li><code>white-space</code></li>
<li><code>bottom</code></li>
<li><code>min-height</code></li>
</ul>
<p>等等, 更多触发 Layout 事件的属性, 可以在 <a href="https://csstriggers.com/" target="_blank" rel="external nofollow noreferrer noopener">CSS Triggers</a> 网站查阅.</p>
<h4 id="Rasterizer"><a href="#Rasterizer" class="headerlink" title="Rasterizer"></a>Rasterizer</h4><p>光栅化, 一般的安卓手机都会进行光栅化, 光栅主要是针对图形的一个栅格化过程. 低端手机在这部分耗时还是蛮多的.</p>
<h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>本质上就是填充像素的过程. 包括绘制文字、颜色、图像、边框和阴影等, 也就是一个 DOM 元素所有的可视效果. 一般来说, 这个绘制过程是在多个层上完成的.</p>
<p>Paint 的工作就是把文档中用户可见的那一部分展现给用户. Paint 是把 Layout 和 Calculate 的计算的结果直接在浏览器视窗上绘制出来, 它并不实现具体的元素计算.</p>
<p>同样, 页面解析完成后, 改变某些样式也会引起 RePaint(重绘).</p>
<p>常见引起 RePaint(重绘) 的样式:</p>
<ul>
<li><code>color</code></li>
<li><code>border-style</code></li>
<li><code>visibility</code></li>
<li><code>background</code></li>
<li><code>text-decoration</code></li>
<li><code>background-image</code></li>
<li><code>background-position</code></li>
<li><code>background-repeat</code></li>
<li><code>outline-color</code></li>
<li><code>outline</code></li>
<li><code>outline-style</code></li>
<li><code>border-radius</code></li>
<li><code>outline-width</code></li>
<li><code>box-shadow</code></li>
<li><code>background-size</code></li>
</ul>
<p>如果你在元素中对以上的属性设置动画, 那么将会引起重绘, 并且元素所属的图层将提交给 GPU 进行处理.<br>对于移动端设备来说, 这代价是非常昂贵的, 因为它们的 CPU 的处理能力明显弱于桌面端. 这意味着, 任务将用更长的时间来完成; 并且 CPU 和 GPU 之间的带宽是有限的, 所以数据的上传需要花费很长的一段时间.</p>
<h4 id="Composite-Layers"><a href="#Composite-Layers" class="headerlink" title="Composite Layers"></a>Composite Layers</h4><p>最后合并图层, 输出页面到屏幕. 浏览器在渲染过程中会将一些含有特殊样式的 DOM 结构绘制于其他图层, 有点类似于<code>PhotoShop</code>的图层概念. 一张图片在<code>PotoShop</code>是由多个图层组合而成, 而浏览器最终显示的页面实际也是有多个图层构成的.</p>
<p>在每个层上完成绘制过程之后, 浏览器会将所有层按照合理的顺序合并成一个图层, 然后在屏幕上呈现. 对于有位置重叠的元素的页面, 这个过程尤其重要, 因为一旦图层的合并顺序出错, 将会导致元素显示异常.</p>
<p>常见的导致新图层创建的因素有:</p>
<ul>
<li>进行 3D 或者透视变换的 CSS 属性</li>
<li>使用硬件加速视频解码的<code>&lt;video&gt;</code>元素</li>
<li>具有 3D(WebGL) 上下文或者硬件加速的 2D 上下文的<code>&lt;canvas&gt;</code>元素</li>
<li>组合型插件 (即 Flash)</li>
<li>具有有 CSS 透明度动画或者使用动画式 Webkit 变换的元素</li>
<li>具有硬件加速的 CSS 滤镜的元素</li>
</ul>
<h3 id="影响动画渲染性能的因素"><a href="#影响动画渲染性能的因素" class="headerlink" title="影响动画渲染性能的因素"></a>影响动画渲染性能的因素</h3><p>上述流程可以归纳为五个关键步骤:</p>
<p><img alt="css-animation-4.jpg" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/css-animation-4.jpg" class="lazyload"></p>
<p>这也是我们在实现动画过程中有可能会触发的五个步骤, 搞清楚我们实现动画的代码在哪一步, 有助于我们实现高性能流畅的动画.<br>在上面的流程中, 我们需要注意两个概念 <strong>重排 (也就是回流)</strong> 和 <strong>重绘</strong>. 这两个概念与上述流程中的 Layout 和 Paint 都有关系, 而 Layout 和 Paint 又对动画渲染的性能至关重要.</p>
<h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p><code>Reflow</code>(重排) 指的是计算页面布局 (Layout). 某个节点<code>Reflow</code>时会重新计算节点的尺寸和位置, 而且还有可能触发其后代节点<code>Reflow</code>. 在这之后再次触发一次<code>Repaint</code>(重绘).</p>
<p>当 Render Tree 中的一部分 (或全部) 因为元素的尺寸、布局、隐藏等改变而需要重新构建. 这就称为回流, 每个页面至少需要一次回流, 就是页面第一次加载的时候.</p>
<p>在 Web 页面中, 很多状况下会导致回流:</p>
<ul>
<li>调整窗口大小</li>
<li>改变字体</li>
<li>增加或者移除样式表</li>
<li>内容变化</li>
<li>激活 CSS 伪类</li>
<li>操作 CSS 属性</li>
<li>JavaScript 操作 DOM</li>
<li>计算<code>offsetWidth</code>和<code>offsetHeight</code></li>
<li>设置<code>style</code>属性的值</li>
<li>CSS3 Animation 或 Transition</li>
</ul>
<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p><code>Repaint</code>(重绘) 或者<code>Redraw</code>遍历所有节点, 检测节点的可见性、颜色、轮廓等可见的样式属性, 然后根据检测的结果更新页面的响应部分.<br>当 Render Tree 中的一些元素需要更新属性, 而这些属性只是影响元素的外观、风格、而不会影响布局的. 就是重绘.</p>
<p>将重排和重绘的介绍结合起来, 不难发现: <strong>重绘 (Repaint) 不一定会引起回流(Reflow 重排), 但回流必将引起重绘(Repaint)</strong>.</p>
<p>由此可见, 重排和重绘很容易被触发, 而他们对动画渲染的性能影响非常大. 我们需要做的是尽量不去触发重绘和重排.</p>
<h3 id="动画渲染性能优化"><a href="#动画渲染性能优化" class="headerlink" title="动画渲染性能优化"></a>动画渲染性能优化</h3><p><strong>过早进行性能优化是大忌</strong>, 如果我们实现的动画并没有性能方面的问题, 就没有必要将时间成本浪费在性能优化上.</p>
<h4 id="在Composite这步优化动画"><a href="#在Composite这步优化动画" class="headerlink" title="在Composite这步优化动画"></a>在<code>Composite</code>这步优化动画</h4><p>在实现用户交互动画的过程中, 我们尽量避免重绘和重排. 现在浏览器可以利用<code>transform</code>和<code>opacity</code>绘制很好的动画. 因为这些属性只会影响<br>浏览器渲染的最后一步<code>Composite</code>过程.</p>
<p>共有四个让动画更好的属性:</p>
<ul>
<li>位置 (Position): <code>transform: translateX(n) translateY(n) translateZ(n)</code></li>
<li>缩放 (Scale): <code>transform: scale(n)</code></li>
<li>旋转 (Rotation): <code>transform: rotate(ndeg)</code></li>
<li>透明度 (Opacity): <code>opacity: n</code></li>
</ul>
<h4 id="在-GPU-上运行动画"><a href="#在-GPU-上运行动画" class="headerlink" title="在 GPU 上运行动画"></a>在 GPU 上运行动画</h4><p>在 CSS 中提供了一个新的 CSS 特性:<code>will-change</code>. 其主要作用就是 <strong>提前告诉浏览器我这里将会进行一些变动, 请分配资源 (告诉浏览器要分配资源给我).</strong> 因此浏览器不需要考虑容器布局的渲染或绘制.</p>
<blockquote>
<p><code>will-change</code>属性, 允许作者提前告知浏览器的默认样式, 那他们可能会做出一个元素. 它允许对浏览器默认样式的优化如何提前处理因素, 在动画实际开始之前, 为准备动画执行潜在昂贵的工作. 有关于<code>will-change</code>更详细的介绍可以<a href="http://www.w3cplus.com/css3/introduction-css-will-change-property.html" target="_blank" rel="external nofollow noreferrer noopener">点击这里</a>.</p>
</blockquote>
<p>在使用<code>will-change</code>一定要注意方式方法, 比如常见的错误方法是直接在<code>:hover</code>是使用, 并没有告诉浏览器分配资源:  </p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span><span class="selector-pseudo">:hover</span> {</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">will-change</span>: transform;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>: transform <span class="number">2s</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(30deg) <span class="built_in">scale</span>(1.5);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>其正确使用的方法是, 在进入父元素的时候就告诉浏览器, 你该分配一定的资源:  </p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> {</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>: opacity .<span class="number">3s</span> linear;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* declare changes on the element when the mouse enters / hovers its ancestor */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ancestor</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.element</span> {</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">will-change</span>: opacity;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* apply change when element is hovered */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span><span class="selector-pseudo">:hover</span> {</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">opacity</span>: .<span class="number">5</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>另外在应用变化之后, 取消<code>will-change</code>的资源分配:  </p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">el.addEventListener(<span class="string">'animationEnd'</span>, removeHint);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHint</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.style.willChange = <span class="string">'auto'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>在使用<code>will-change</code>时, 还需注意:</p>
<ul>
<li>不要将<code>will-change</code>应用到太多元素上: 浏览器已经尽力尝试去优化一切可以优化的东西了. 有一些更强力的优化, 如果与<code>will-change</code>结合在一起的话, 有可能会消耗很多机器资源, 如果过度使用的话, 可能导致页面响应缓慢或者消耗非常多的资源.</li>
<li>有节制地使用: 通常, 当元素恢复到初始状态时, 浏览器会丢弃掉之前做的优化工作. 但是如果直接在样式表中显式声明了<code>will-change</code>属性, 则表示目标元素可能会经常变化, 浏览器会将优化工作保存得比之前更久. 所以最佳实践是当元素变化之前和之后通过脚本来切换<code>will-change</code>的值.</li>
<li>不要过早应用<code>will-change</code>优化: 如果你的页面在性能方面没什么问题, 则不要添加<code>will-change</code>属性来榨取一丁点的速度.<code>will-change</code>的设计初衷是作为最后的优化手段, 用来尝试解决现有的性能问题. 它不应该被用来预防性能问题. 过度使用<code>will-change</code>会导致大量的内存占用, 并会导致更复杂的渲染过程, 因为浏览器会试图准备可能存在的变化过程. 这会导致更严重的性能问题.</li>
<li>给它足够的工作时间: 这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的. 然后浏览器可以选择在变化发生前提前去做一些优化工作. 所以给浏览器一点时间去真正做这些优化工作是非常重要的. 使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化, 然后为它加上 <code>will-change</code>属性.</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering/" target="_blank" rel="external nofollow noreferrer noopener">Javascript 高性能动画与页面渲染</a></li>
<li><a href="http://www.w3cplus.com/animation/how-to-achieve-60-fps-animations-with-css3.html" target="_blank" rel="external nofollow noreferrer noopener">使用 CSS3 实现 60FPS 动画</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/" target="_blank" rel="external nofollow noreferrer noopener">High Performance Animations</a></li>
<li><a href="http://bubkoo.com/2016/03/31/high-performance-animations/" target="_blank" rel="external nofollow noreferrer noopener">使用 FLIP 来提高 Web 动画的性能</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="external nofollow noreferrer noopener">浏览器的工作原理：新式网络浏览器幕后揭祕</a></li>
<li><a href="http://www.w3cplus.com/animation/animation-performance.html" target="_blank" rel="external nofollow noreferrer noopener">CSS Animation 性能优化</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></iframe></div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS    </a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/animation_optimize_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/image/wechat.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/image/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><div class="post-ad"><ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-fb+5w+4e-db+86" data-ad-client="ca-pub-8919908724705274" data-ad-slot="5978969231"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});
</script></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/c621cf12/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/Windows_Terminal_cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>添加Windows Terminal到鼠标右键菜单</span></div></a></div><div class="next-post pull_right"><a href="/posts/20bbe8ff/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter_cover.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>在浏览器输入 URL 回车之后发生了什么（超详细版）</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'PFdiF3pQOKd2cMhsTRt7bDYT',
  appKey:'WprfuKVn4SHdhAU8UqjC0Fyb',
  placeholder:'记得得留下你的昵称和邮箱....可以快速收到回復',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer id="footer" style="background-image: url(/static/cover/11867.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2021 By 萧</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" rel="external nofollow noreferrer" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script async src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@latest/js/canvas-nest.js"></script><script src="/js/baidupush.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/jerryc127.github.io@latest/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@latest/js/ClickShowText.js"></script><script>if('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw-cn.js')
  .then(reg => {
      reg.addEventListener('updatefound', () => {
          newWorker = reg.installing;
          newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed') {
                  if (navigator.serviceWorker.controller) {
                    var bg = document.documentElement.getAttribute('data-theme') === 'light' ? GLOBAL_CONFIG.Snackbar.bgLight : GLOBAL_CONFIG.Snackbar.bgDark;
                    var position = GLOBAL_CONFIG.Snackbar.position;
                    Snackbar.show({
                      text: '已更新最新版本',
                      backgroundColor: bg,
                      duration: 3000,
                      pos: position,
                      actionText: '點擊刷新',
                      onActionClick: function(element) {
                        location.reload();
                       }
                    });

                  }
                }
            });
        });
    });
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>